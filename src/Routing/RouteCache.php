<?php

declare(strict_types=1);

namespace Toporia\Framework\Routing;

use Toporia\Framework\Routing\Contracts\RouteCacheInterface;

/**
 * Class RouteCache
 *
 * File-based route caching implementation for maximum performance.
 * Provides opcache-compatible caching with atomic file writing for safety.
 *
 * @author      Phungtruong7820 <minhphung485@gmail.com>
 * @copyright   Copyright (c) 2025 Toporia Framework
 * @license     MIT
 * @version     1.0.0
 * @package     toporia/framework
 * @subpackage  Routing
 * @since       2025-01-10
 *
 * @link        https://github.com/Minhphung7820/toporia
 */
final class RouteCache implements RouteCacheInterface
{
    /**
     * @var string Cache file path
     */
    private string $cachePath;

    /**
     * @param string $cachePath Path to cache directory
     */
    public function __construct(string $cachePath)
    {
        $this->cachePath = rtrim($cachePath, '/') . '/routes.php';
    }

    /**
     * {@inheritdoc}
     */
    public function isCached(): bool
    {
        return file_exists($this->cachePath);
    }

    /**
     * {@inheritdoc}
     */
    public function get(): ?array
    {
        if (!$this->isCached()) {
            return null;
        }

        try {
            // Include returns array - opcache friendly!
            $routes = include $this->cachePath;

            if (!is_array($routes)) {
                return null;
            }

            return $routes;
        } catch (\Throwable $e) {
            return null;
        }
    }

    /**
     * {@inheritdoc}
     */
    public function put(array $routes): bool
    {
        try {
            // Ensure cache directory exists
            $dir = dirname($this->cachePath);
            if (!is_dir($dir)) {
                mkdir($dir, 0755, true);
            }

            // Generate PHP file content
            $content = $this->generateCacheFile($routes);

            // Atomic write: write to temp file then rename
            $tempPath = $this->cachePath . '.tmp';
            file_put_contents($tempPath, $content, LOCK_EX);

            // Atomic rename (avoids partial reads)
            rename($tempPath, $this->cachePath);

            // Clear opcache for this file
            if (function_exists('opcache_invalidate')) {
                opcache_invalidate($this->cachePath, true);
            }

            return true;
        } catch (\Throwable $e) {
            return false;
        }
    }

    /**
     * {@inheritdoc}
     */
    public function clear(): bool
    {
        if (!$this->isCached()) {
            return true;
        }

        try {
            unlink($this->cachePath);

            // Clear opcache
            if (function_exists('opcache_invalidate')) {
                opcache_invalidate($this->cachePath, true);
            }

            return true;
        } catch (\Throwable $e) {
            return false;
        }
    }

    /**
     * {@inheritdoc}
     */
    public function getCachePath(): string
    {
        return $this->cachePath;
    }

    /**
     * Generate cache file content.
     *
     * Performance: var_export is faster than serialize and opcache-friendly.
     *
     * @param array $routes Routes data
     * @return string PHP file content
     */
    private function generateCacheFile(array $routes): string
    {
        $export = var_export($routes, true);

        return <<<PHP
<?php

/**
 * Cached Routes
 *
 * This file is auto-generated by route:cache command.
 * Do not edit manually!
 *
 * Regenerate with: php console route:cache
 * Clear with: php console route:clear
 */

return {$export};

PHP;
    }
}
